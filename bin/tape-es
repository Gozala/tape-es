#!/usr/bin/env node

import { join } from 'path';
import {exists, readFile } from 'fs';
import glob from 'glob';
import { promisify } from 'util';
const fileExistsAsync = promisify(exists);
const readFileAsync = promisify(readFile);
const globAsync = promisify(glob);
import cli from 'commander';
import { spawn } from 'child_process';
import eachLimit from 'async/eachLimit.js';

const PKG_PATH = join(new URL(import.meta.url).pathname, '../../package.json');
const DEFAULT_PATTERN = '**/*.spec.js';
const DEFAULT_IGNORE = "**/node_modules/**";
const DEFAULT_ROOT = join(process.cwd());
const DEFAULT_THREADS = 10;

(async () => {
  const pkg = await readPkg(PKG_PATH);

  cli.version(pkg.version);
  cli.arguments('[pattern]')
  cli.option('-i, --ignore <value>', 'Ignore files pattern')
  cli.option('-r, --root <value>', 'The root path')
  cli.option('-t, --threads <number>', 'Number of threads to run tests concurrently', parseInt)
  cli.option('')
  cli.parse(process.argv);

  // glob match to fetch the test file list
  const tests = await match(cli.args[0], cli.ignore, cli.root);

  // run the tests
  run(tests, cli.threads, cli.root)
})().catch(e => {
  console.error(e);
});

async function readPkg (path) {
  if (!await fileExistsAsync(path)) {
    throw Error('ERR_CONFIG: package.json not found, is this a package?');
  }

  try {
    return JSON.parse(await readFileAsync(path, 'utf-8'));
  } catch {
    throw Error('ERR_CONFIG: Failed to read package.json');
  }
}

async function match (pattern = DEFAULT_PATTERN, ignore = DEFAULT_IGNORE, root = DEFAULT_ROOT) {
  return await globAsync(pattern, { cwd: root, ignore });
}

function run (tests, max = DEFAULT_THREADS, root = DEFAULT_ROOT) {
  eachLimit(tests, max, function(test, callback) {
    spawn("node", [test], {
      cwd: root,
      stdio: ['pipe', process.stdout, process.stderr]
    }).on("close", msg => {
      if (msg === 1) { process.exitCode = 1; }
      callback();
    }).on("error", err => {
      console.err(err);
      callback();
    });
  });
}
